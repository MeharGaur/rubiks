import { BoxGeometry, Color, Float32BufferAttribute, Group, Mesh, MeshBasicMaterial, Quaternion, Scene, Vector3 } from 'three'
import { gsap } from 'gsap'

import { getCommandByCode } from './Commands'
import { ALL_COMMAND_CODES, ALL_FACELET_POSITIONS, Colors } from './Types'
import type { Command, CommandCode, Face } from './Types'
import Queue from './Queue'
import { DIMENSIONS, PIECE_SIZE, SOLVED_CUBE } from './Config'
import { Piece, colorMap, piecesData } from './Piece'
import { Facelet, getIndexFromFace } from './Facelet'
import { shuffle } from './Utils'

//

export default class Cube {
  
  /** Dimensions for the cube, default 3x3 */
  private dimensions: number = DIMENSIONS
  
  /** Size of each piece, currently 0.33 world units */
  private pieceSize: number = PIECE_SIZE

  /** Size of the whole cube in world units */
  private cubeSize: number

  /** 
   * Default is a solved cube
   * https://github.com/muodov/kociemba#cube-string-notation
   */
  private faceString: string = SOLVED_CUBE
  
  private pieces: Array<Piece> = [ ]
  private cubeGroup: Group = new Group()
  private commandQueue: Queue = new Queue(this.executeCommand.bind(this))
  
  findSolution: (number, string) => string
  tempo: number = Tempos.Normal

  //

  constructor(private scene: Scene) {

    this.loadBackend()

    this.cubeSize = this.dimensions * this.pieceSize

    /** Offset by half of the total cube size in each axis so it's centered in the world */
    const pieceSizeOffset = (this.cubeSize / 2) - (this.pieceSize / 2)

    // TODO: We want a nice brushed steel kinda material, would need to figure out the colors tho
    // TODO: Put black gaps between the cubes like how it would be in real life?
    const material = new MeshBasicMaterial({ vertexColors: true })

    // Generate the pieces (aka cubelets) 
    for (const { indices, positions } of piecesData) {
      const facelets: Array<Facelet> = [ ]

      for (let i = 0; i < positions.length; i++) {
        facelets.push(
          new Facelet(positions[i], colorMap[ positions[i][0] ])
        )
      }

      const geometry = 
        new BoxGeometry(this.pieceSize, this.pieceSize, this.pieceSize)
        .toNonIndexed()

      geometry.setAttribute(
        'color', 
        new Float32BufferAttribute(
          this.generateFaceletColors(facelets), 
          3 
        )
      )

      const mesh = new Mesh(geometry, material)

      // Set the position for the piece based on the current index of each axis
      mesh.position.x = (indices.x * this.pieceSize) - pieceSizeOffset
      mesh.position.y = (indices.y * this.pieceSize) - pieceSizeOffset
      mesh.position.z = (indices.z * this.pieceSize) - pieceSizeOffset

      // Add each piece mesh to the scene so it renders
      // Delay each cube one by one:   setTimeout(() => , 1000 * (indices.x * 9 + indices.y * 3 + indices.z))
      this.cubeGroup.add(mesh)

      this.pieces.push(new Piece(
        indices, facelets, mesh, this.pieceSize, pieceSizeOffset
      ))
    }

    this.scene.add(this.cubeGroup) 
  }

  //

  /** Scramble the cube to a random configuration */
  scramble() {
    const randomCommands = this.randomCommandString()
    console.log(randomCommands)

    this.tempo = Tempos.Scramble

    this.move(randomCommands)
  }

  /** Solve the cube using kociemba two-phase */
  solve() {
    this.updateFaceString()

    this.tempo = Tempos.Normal

    // this.move(
    //   this.findSolution(2, this.faceString)
    // )
  }

  /** 
   * Parse a string of command codes, enqueue each command.
   * e.x. "U L R U F R' B D U'"
   * https://ruwix.com/the-rubiks-cube/notation/
   * https://ruwix.com/the-rubiks-cube/notation/advanced/
   */
  move(commandString: string) {
    const commandCodes = <Array<CommandCode>> commandString.split(' ')

    for (let commandCode of commandCodes) {
      /** Set the number of repetitions to 1 by default. Repetition amounts are single-digit */
      const repetitionsToExecute = parseInt(commandCode.slice(-1)) || 1

      // Need just the letters if repetitions is specified
      if (repetitionsToExecute > 1) {
        commandCode = <CommandCode> commandCode.slice(0, -1)
      }

      const command = getCommandByCode(
        <CommandCode> commandCode, 
        repetitionsToExecute
      )

      if (command) {
        this.commandQueue.enqueue(command)
      }
      else {
        console.warn(`${ commandCode } is an invalid command code. Refer to Commands.ts for valid command codes.`)
      }
    }
  }

  //

  private onLoad() {
    // this.scramble()
  }

  // TODO: Reduce the filesize of solve.js generated by emscripten as much as possible. Don't need all the extra node stuff or whatever.
  private loadBackend() {
    window.Module = {
      onRuntimeInitialized: () => {
        this.findSolution = window.Module.cwrap('solve', 'string', [ 'number', 'string' ])

        this.onLoad()
      },

      locateFile: (fileName) => {
        return `${ window.location.href }backend/${ fileName }`
      }
    }

    // Run Emscripten glue code if not already run
    if (!document.querySelector('#solver')) {
      const script = document.createElement('script')
      script.src = '/backend/solve.js'
      script.async = true
      script.id = "solver"
      document.body.appendChild(script)
      // script.onload = () => { } // could return a promise
    }
  }

  //

  private randomCommandString() {
    // ***** Make sure it generates only valid definitions
    return shuffle([ ...ALL_COMMAND_CODES,  ...ALL_COMMAND_CODES ]).join(' ')
  }

  //

  private updateFaceString() {
    const faceString: Array<Face> = [ ]
  
    for (const faceletPosition of ALL_FACELET_POSITIONS) {
      const pieceData = piecesData.find((pieceData) => (
        pieceData.positions.includes(faceletPosition)
      ))

      const piece = this.pieces.find((piece) => (
        pieceData.indices.equals(new Vector3(
          Math.round((piece.mesh.position.x + piece.offset) / piece.size),
          Math.round((piece.mesh.position.y + piece.offset) / piece.size),
          Math.round((piece.mesh.position.z + piece.offset) / piece.size),
        ))
      ))
      
      const face = faceletPosition[0]
      console.log(face)
      const faces = [ ]
      // const index = getIndexFromFace( faceletPosition[0] ) * 18

      const colors = piece.mesh.geometry.getAttribute('color').array
      const positions = piece.mesh.geometry.getAttribute('position').array

      const increment = colors.length / 6

      for (let i = (increment - 1); i < colors.length; i += increment) {
        const color = new Color(
          colors[i - 2], 
          colors[i - 1], 
          colors[i    ]
        )

        if (!color.getHex()) {
          continue
        }
        
        const averagePosition = new Vector3()

        for (let j = 0; j < 6; j++) {
          averagePosition.add(new Vector3(
            positions[i - 2], 
            positions[i - 1], 
            positions[i    ],
          ))
        }

        averagePosition.divide(new Vector3(6, 6, 6))

        faces.push({
          color,
          position: averagePosition
        })
      }

      console.log(faces)

      let compare: (a, b) => boolean
      let faceData

      if (face == 'U') {
        compare = (a, b) => b.position.y > a.position.y
      }    
      else if (face == 'R') {
        compare = (a, b) => b.position.x > a.position.x
      }  
      else if (face == 'F') {
        compare = (a, b) => b.position.z > a.position.z
      }  
      else if (face == 'D') {
        compare = (a, b) => b.position.y < a.position.y
      }  
      else if (face == 'L') {
        compare = (a, b) => b.position.x < a.position.x
      }  
      else if (face == 'B') {
        compare = (a, b) => b.position.z < a.position.z
      }  

      faceData = faces.reduce((accumulator, faceData) => {
        if (compare(accumulator, faceData)) {
          console.log('xddd')
          return faceData
        }
        else {
          return accumulator
        }
      }, faces[0])

      console.log(faceData)

      faceString.push(colorMap[faceData.color.getHex()])
      

      // Every vertex in a face is going to be the same color, can pick 
      // RGB from anywhere so long as it's a consecutive group of three
      // const hexCode = new Color(
      //     colors[index    ],
      //     colors[index + 1],
      //     colors[index + 2],
      //   )
      //   .getHex()
      
      // // Don't save if it's facing inwards (0x000000 hex code)
      // if (hexCode) {
      //   console.log(colorMap[hexCode])
      //   faces.push(colorMap[hexCode])
      // }
      // else {
      //   console.log('found black')
      // }

      console.log(`~~~~~~~~~~~~~~~~`)
    }

    console.log(faceString.length)
    console.log(faceString.join(''))

    this.faceString = faceString.join('')
  }

  //

  /**
   * A buffer attribute of a mesh is always a flat array, so we need to 
   * generate a colors array with each RGB value in the right order.
   */
  private generateFaceletColors(facelets) {

    const faceletColorIndices = [ ]

    for (const facelet of facelets) {
      faceletColorIndices[ getIndexFromFace( facelet.position[0] ) ] = 
        facelet.hexCode
    }

    const colors = [ ]
    const color = new Color()

    for (let i = 0; i < 6; i++) {
      let colorHex

      if (faceletColorIndices[i]) {
        colorHex = faceletColorIndices[i]
      }
      else {
        colorHex = 0x000000
      }

      color.set(colorHex)

      for (let i = 0; i < 6; i++) {
        colors.push(color.r, color.g, color.b)
      }
    }

    return colors
  }
  
  //

  /**
   * Execute the command currently at the top of the queue. Calls itself 
   * recursively until the queue is empty.
   * 
   * TODO: Cubes are not updating in time only in middle layer selection
   */
  private async executeCommand(command: Command) {

    const layerGroup = new Group()

    const selectedPieces = command.selector(this.pieces)

    for (const piece of selectedPieces) {
      layerGroup.add(piece.mesh)
    }

    this.cubeGroup.add(layerGroup)

    // TODO: pile all the commands onto a gsap timeline so we can set ease and duration for the whole thing. 

    await gsap.to(layerGroup.rotation, {
      [ command.axis ]: `
        ${ command.direction }=${ (Math.PI / 2) * command.repetitions }
      `,

      ...this.calculateTweenVars(command.repetitions)
    })

    // THREE does not retain local transforms if you remove a child from a group.
    // Save the current transforms, remove from layer group, add back transforms
    for (const piece of selectedPieces) {
      const position = piece.mesh.getWorldPosition(new Vector3())
      const quaternion = piece.mesh.getWorldQuaternion(new Quaternion())

      this.cubeGroup.add(piece.mesh)

      piece.mesh.position.copy(position)
      piece.mesh.quaternion.copy(quaternion) 
    }

    // Get rid of layer so it doesn't count as a child of cubeGroup
    layerGroup.removeFromParent()

    // Dequeue this command so the next one can execute
    this.commandQueue.dequeue()

    // Will call itself recursively until queue is empty
    if (this.commandQueue.commands.length > 0) {
      this.executeCommand(this.commandQueue.commands[0])
    }
  }

  private calculateTweenVars(repetitions: number) {
    if (this.tempo == Tempos.Normal) {
      return {
        duration: 0.7 + (repetitions * 0.3),
        ease: 'back.inOut(1)'
      }
    }
    else if (this.tempo == Tempos.Scramble) {
      return {
        duration: 0.15,
        ease: 'Power1.inOut'
      }
    }
  }

  //

}


enum Tempos {
  Normal = 1,

  Scramble = 2
}

